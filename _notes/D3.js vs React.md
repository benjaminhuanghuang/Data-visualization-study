# D3.js vs React

The key challenge is that both React (using a virtual DOM) and D3 (using direct DOM manipulation) want control over the same elements.

- React's Role: Manage application state, data flow, component lifecycle, and render all non-chart UI elements.

- D3's Role: Use its powerful data visualization tools (scales, axes, shapes, animations) to draw within a designated container element managed by React.

The most modern and recommended way to integrate D3 with React functional components uses useRef to access the DOM node and useEffect to run D3 code after the component mounts.

```js

import React, { useRef, useEffect } from 'react';
import * as d3 from 'd3';

const BarChart = ({ data }) => {
  const svgRef = useRef(null);
  // ... rest of the component

  useEffect(() => {
  // Select the container using d3.select(ref.current)
  const svg = d3.select(svgRef.current);

  // Use D3 to create scales, axes, and append elements (rects, circles, etc.)
  // Example: svg.selectAll("rect").data(data).enter().append("rect")...

  // You can also create separate, reusable D3 functions and call them here.
  }, [data]); // Add 'data' as a dependency if the chart should update with new data

  return (
    <svg ref={svgRef} width={600} height={400}>
      {/* D3 will populate this SVG */}
    </svg>
  );
};

export default BarChart;

```

## 方式一：D3 只做「计算」（最推荐）

- 完全 React 风格
- 无 DOM 冲突
- 易维护、易测试

```js
import * as d3 from "d3";

const data = [30, 80, 45, 60];

export default function BarChart() {
  const width = 400;
  const height = 200;

  const xScale = d3
    .scaleBand()
    .domain(data.map((_, i) => i))
    .range([0, width])
    .padding(0.1);

  const yScale = d3
    .scaleLinear()
    .domain([0, d3.max(data)])
    .range([height, 0]);

  return (
    <svg width={width} height={height}>
      {data.map((d, i) => (
        <rect
          key={i}
          x={xScale(i)}
          y={yScale(d)}
          width={xScale.bandwidth()}
          height={height - yScale(d)}
          fill="steelblue"
        />
      ))}
    </svg>
  );
}
```

## 二：D3 通过 ref 操作 DOM（局部）

- 坐标轴（axis）
- 复杂动画
- force / zoom

```js
import { useRef, useEffect } from "react";
import * as d3 from "d3";

export default function Axis({ scale, transform }) {
  const ref = useRef();

  useEffect(() => {
    d3.select(ref.current).call(d3.axisLeft(scale));
  }, [scale]);

  return <g ref={ref} transform={transform} />;
}

```

## 三：完全用 D3（不推荐）

❌ 不可控
❌ 难以与 React 状态同步
❌ 不适合大型应用

```js
useEffect(() => {
  d3.select(svgRef.current)
    .append("circle")
}, []);
```
